import * as SQLite from 'expo-sqlite';
import type { CollectionItem, Metal } from '../types';

const db = SQLite.openDatabaseSync('bullion.db');

/**
 * Initialize the database with the schema
 */
export async function initDatabase(): Promise<void> {
  try {
    await db.execAsync(`
      CREATE TABLE IF NOT EXISTS collection (
        id TEXT PRIMARY KEY,
        name TEXT NOT NULL,
        metal TEXT NOT NULL CHECK(metal IN ('gold', 'silver', 'platinum')),
        weight REAL NOT NULL,
        quantity INTEGER NOT NULL DEFAULT 1,
        purity REAL NOT NULL,
        purchase_price REAL NOT NULL,
        purchase_date TEXT NOT NULL,
        notes TEXT,
        image_uri TEXT,
        sort_order INTEGER NOT NULL DEFAULT 0,
        created_at TEXT NOT NULL DEFAULT (datetime('now')),
        updated_at TEXT NOT NULL DEFAULT (datetime('now'))
      );

      CREATE INDEX IF NOT EXISTS idx_collection_sort_order ON collection(sort_order);
      CREATE INDEX IF NOT EXISTS idx_collection_metal ON collection(metal);
    `);

    // Migration: Add quantity column if it doesn't exist
    try {
      await db.execAsync(`ALTER TABLE collection ADD COLUMN quantity INTEGER NOT NULL DEFAULT 1;`);
      console.log('Database migrated: added quantity column');
    } catch (error: any) {
      // Column already exists or other error - ignore
      if (!error.message?.includes('duplicate column')) {
        console.log('Quantity column already exists or migration not needed');
      }
    }

    console.log('Database initialized successfully');
  } catch (error) {
    console.error('Failed to initialize database:', error);
    throw error;
  }
}

/**
 * Get all collection items ordered by sort_order
 */
export async function getAllItems(): Promise<CollectionItem[]> {
  const result = await db.getAllAsync<any>(
    'SELECT * FROM collection ORDER BY sort_order ASC, created_at DESC'
  );

  return result.map(row => ({
    id: row.id,
    name: row.name,
    metal: row.metal as Metal,
    weight: row.weight,
    quantity: row.quantity || 1,
    purity: row.purity,
    purchasePrice: row.purchase_price,
    purchaseDate: row.purchase_date,
    notes: row.notes || undefined,
    imageUri: row.image_uri || undefined,
    sortOrder: row.sort_order,
    createdAt: row.created_at,
    updatedAt: row.updated_at,
  }));
}

/**
 * Get a single item by ID
 */
export async function getItemById(id: string): Promise<CollectionItem | null> {
  const result = await db.getFirstAsync<any>(
    'SELECT * FROM collection WHERE id = ?',
    [id]
  );

  if (!result) return null;

  return {
    id: result.id,
    name: result.name,
    metal: result.metal as Metal,
    weight: result.weight,
    quantity: result.quantity || 1,
    purity: result.purity,
    purchasePrice: result.purchase_price,
    purchaseDate: result.purchase_date,
    notes: result.notes || undefined,
    imageUri: result.image_uri || undefined,
    sortOrder: result.sort_order,
    createdAt: result.created_at,
    updatedAt: result.updated_at,
  };
}

/**
 * Create a new collection item
 */
export async function createItem(
  item: Omit<CollectionItem, 'id' | 'createdAt' | 'updatedAt' | 'sortOrder'>
): Promise<CollectionItem> {
  const id = generateId();
  const now = new Date().toISOString();

  // Get max sort order
  const maxSortResult = await db.getFirstAsync<{ max_sort: number | null }>(
    'SELECT MAX(sort_order) as max_sort FROM collection'
  );
  const sortOrder = (maxSortResult?.max_sort ?? -1) + 1;

  await db.runAsync(
    `INSERT INTO collection (
      id, name, metal, weight, quantity, purity, purchase_price, purchase_date,
      notes, image_uri, sort_order, created_at, updated_at
    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
    [
      id,
      item.name,
      item.metal,
      item.weight,
      item.quantity,
      item.purity,
      item.purchasePrice,
      item.purchaseDate,
      item.notes || null,
      item.imageUri || null,
      sortOrder,
      now,
      now,
    ]
  );

  const newItem = await getItemById(id);
  if (!newItem) throw new Error('Failed to create item');
  return newItem;
}

/**
 * Update an existing collection item
 */
export async function updateItem(
  id: string,
  updates: Partial<Omit<CollectionItem, 'id' | 'createdAt' | 'updatedAt'>>
): Promise<CollectionItem> {
  const now = new Date().toISOString();

  const fields: string[] = [];
  const values: any[] = [];

  if (updates.name !== undefined) {
    fields.push('name = ?');
    values.push(updates.name);
  }
  if (updates.metal !== undefined) {
    fields.push('metal = ?');
    values.push(updates.metal);
  }
  if (updates.weight !== undefined) {
    fields.push('weight = ?');
    values.push(updates.weight);
  }
  if (updates.quantity !== undefined) {
    fields.push('quantity = ?');
    values.push(updates.quantity);
  }
  if (updates.purity !== undefined) {
    fields.push('purity = ?');
    values.push(updates.purity);
  }
  if (updates.purchasePrice !== undefined) {
    fields.push('purchase_price = ?');
    values.push(updates.purchasePrice);
  }
  if (updates.purchaseDate !== undefined) {
    fields.push('purchase_date = ?');
    values.push(updates.purchaseDate);
  }
  if (updates.notes !== undefined) {
    fields.push('notes = ?');
    values.push(updates.notes || null);
  }
  if (updates.imageUri !== undefined) {
    fields.push('image_uri = ?');
    values.push(updates.imageUri || null);
  }
  if (updates.sortOrder !== undefined) {
    fields.push('sort_order = ?');
    values.push(updates.sortOrder);
  }

  fields.push('updated_at = ?');
  values.push(now);

  values.push(id);

  await db.runAsync(
    `UPDATE collection SET ${fields.join(', ')} WHERE id = ?`,
    values
  );

  const updatedItem = await getItemById(id);
  if (!updatedItem) throw new Error('Failed to update item');
  return updatedItem;
}

/**
 * Delete a collection item
 */
export async function deleteItem(id: string): Promise<void> {
  await db.runAsync('DELETE FROM collection WHERE id = ?', [id]);
}

/**
 * Update sort order for multiple items
 */
export async function updateSortOrders(items: Array<{ id: string; sortOrder: number }>): Promise<void> {
  await db.withTransactionAsync(async () => {
    for (const item of items) {
      await db.runAsync(
        'UPDATE collection SET sort_order = ?, updated_at = ? WHERE id = ?',
        [item.sortOrder, new Date().toISOString(), item.id]
      );
    }
  });
}

/**
 * Generate a simple unique ID
 */
function generateId(): string {
  return Date.now().toString(36) + Math.random().toString(36).substring(2);
}

---
phase: 03-security-hardening
plan: 02
type: execute
---

<objective>
Add rate limiting to authentication endpoints to prevent brute force attacks.

Purpose: Protect auth endpoints from credential stuffing and brute force attacks.
Output: Rate-limited signin/signup endpoints using upstash/ratelimit.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/codebase/CONCERNS.md

# Source files to modify:
@bullion-tracker/src/app/api/auth/signup/route.ts
@bullion-tracker/src/app/api/auth/mobile/signin/route.ts
@bullion-tracker/src/app/api/auth/[...nextauth]/route.ts

**Security issue from CONCERNS.md:**
- No rate limiting on auth endpoints - vulnerable to brute force attacks
- Recommendation: Add upstash/ratelimit middleware

**Prior plan context:**
- 03-01 hardened JWT secrets and password requirements
- This plan adds the rate limiting layer
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install and configure upstash/ratelimit</name>
  <files>bullion-tracker/package.json, bullion-tracker/src/lib/ratelimit.ts</files>
  <action>
    1. Install packages:
    ```bash
    cd bullion-tracker && npm install @upstash/ratelimit @upstash/redis
    ```

    2. Create rate limiter utility at `src/lib/ratelimit.ts`:
    ```typescript
    import { Ratelimit } from '@upstash/ratelimit';
    import { Redis } from '@upstash/redis';

    // Use in-memory store for development (no Upstash account needed)
    // In production, configure UPSTASH_REDIS_REST_URL and UPSTASH_REDIS_REST_TOKEN
    const redis = process.env.UPSTASH_REDIS_REST_URL
      ? new Redis({
          url: process.env.UPSTASH_REDIS_REST_URL,
          token: process.env.UPSTASH_REDIS_REST_TOKEN!,
        })
      : null;

    // Auth rate limiter: 5 requests per 60 seconds per IP
    export const authRateLimiter = redis
      ? new Ratelimit({
          redis,
          limiter: Ratelimit.slidingWindow(5, '60 s'),
          analytics: true,
          prefix: 'ratelimit:auth',
        })
      : null;

    // Helper to get client IP
    export function getClientIp(request: Request): string {
      const forwarded = request.headers.get('x-forwarded-for');
      if (forwarded) {
        return forwarded.split(',')[0].trim();
      }
      return request.headers.get('x-real-ip') || 'unknown';
    }

    // Rate limit check helper
    export async function checkRateLimit(
      identifier: string
    ): Promise<{ success: boolean; remaining?: number; reset?: number }> {
      if (!authRateLimiter) {
        // No rate limiting in development without Upstash
        return { success: true };
      }

      const result = await authRateLimiter.limit(identifier);
      return {
        success: result.success,
        remaining: result.remaining,
        reset: result.reset,
      };
    }
    ```

    Why: upstash/ratelimit is the standard for serverless rate limiting. In-memory fallback means dev works without setup.
  </action>
  <verify>
    1. `npm ls @upstash/ratelimit` shows package installed
    2. File exists: `bullion-tracker/src/lib/ratelimit.ts`
    3. TypeScript compiles: `npx tsc --noEmit` passes
  </verify>
  <done>Rate limiter utility created with Upstash integration and dev fallback.</done>
</task>

<task type="auto">
  <name>Task 2: Add rate limiting to auth endpoints</name>
  <files>bullion-tracker/src/app/api/auth/signup/route.ts, bullion-tracker/src/app/api/auth/mobile/signin/route.ts</files>
  <action>
    Add rate limiting check at the start of both POST handlers:

    In signup/route.ts and mobile/signin/route.ts, add after imports:
    ```typescript
    import { checkRateLimit, getClientIp } from '@/lib/ratelimit';
    ```

    At the start of POST function:
    ```typescript
    // Rate limit check
    const clientIp = getClientIp(request);
    const { success, remaining, reset } = await checkRateLimit(clientIp);

    if (!success) {
      return NextResponse.json(
        { error: 'Too many requests. Please try again later.' },
        {
          status: 429,
          headers: {
            'Retry-After': String(Math.ceil((reset || Date.now() + 60000 - Date.now()) / 1000)),
            'X-RateLimit-Remaining': '0',
          },
        }
      );
    }
    ```

    Why: IP-based rate limiting prevents brute force. 5 req/60s is strict enough to stop attacks but lenient for legitimate users.
  </action>
  <verify>
    1. With Upstash configured: 6th request within 60s returns 429
    2. Without Upstash (dev): Requests always succeed (no rate limiting)
    3. 429 response includes Retry-After header
  </verify>
  <done>Auth endpoints rate limited. Returns 429 with retry info on limit exceeded.</done>
</task>

<task type="auto">
  <name>Task 3: Update .env.example with rate limit vars</name>
  <files>bullion-tracker/.env.example</files>
  <action>
    Add Upstash configuration variables to .env.example:

    ```
    # Rate Limiting (Optional - uses in-memory fallback without these)
    # Get from https://console.upstash.com
    UPSTASH_REDIS_REST_URL=
    UPSTASH_REDIS_REST_TOKEN=

    # Admin Seed Key (Optional - for protected seed endpoint in dev)
    ADMIN_SEED_KEY=
    ```

    Add comment explaining the rate limiting setup.

    Why: Developers need to know these vars exist. Optional nature should be clear.
  </action>
  <verify>
    1. .env.example contains UPSTASH_REDIS_REST_URL
    2. .env.example contains UPSTASH_REDIS_REST_TOKEN
    3. Comments explain optional nature
  </verify>
  <done>.env.example documents rate limiting configuration.</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds without errors
- [ ] Rate limiter utility compiles without TypeScript errors
- [ ] Auth endpoints have rate limit checks
- [ ] .env.example updated with new vars
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- No TypeScript errors
- Rate limiting functional (with Upstash) or gracefully disabled (without)
- Phase 3: Security Hardening complete
</success_criteria>

<output>
After completion, create `.planning/phases/03-security-hardening/03-02-SUMMARY.md`
</output>
